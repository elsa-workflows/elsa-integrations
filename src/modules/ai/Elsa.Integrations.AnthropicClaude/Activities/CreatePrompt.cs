using Elsa.Integrations.AnthropicClaude.Models;
using Elsa.Workflows;
using Elsa.Workflows.Attributes;
using Elsa.Workflows.Models;
using JetBrains.Annotations;

namespace Elsa.Integrations.AnthropicClaude.Activities;

/// <summary>
/// Creates a prompt and sends it to Claude AI for completion.
/// </summary>
[Activity(
    "Elsa.AnthropicClaude.Completions",
    "Anthropic Claude",
    "Creates a prompt based on structured input messages and gets a response from Claude AI.",
    DisplayName = "Create Prompt")]
[UsedImplicitly]
public class CreatePrompt : ClaudeActivity
{
    /// <summary>
    /// The model to use for the completion (e.g., claude-3-sonnet-20240229, claude-3-haiku-20240307).
    /// </summary>
    [Input(
        Description = "The Claude model to use for completion. Popular options: claude-3-sonnet-20240229, claude-3-haiku-20240307, claude-3-opus-20240229",
        DefaultValue = "claude-3-sonnet-20240229")]
    public Input<string> Model { get; set; } = new("claude-3-sonnet-20240229");

    /// <summary>
    /// The system prompt that defines Claude's behavior and context.
    /// </summary>
    [Input(
        Description = "System prompt that defines Claude's behavior, role, and context for the conversation.",
        UIHint = "multiline")]
    public Input<string?> SystemPrompt { get; set; } = null!;

    /// <summary>
    /// The user message or prompt to send to Claude.
    /// </summary>
    [Input(
        Description = "The user message or prompt to send to Claude.",
        UIHint = "multiline")]
    public Input<string> UserMessage { get; set; } = null!;

    /// <summary>
    /// Previous messages in the conversation (JSON array of messages with 'role' and 'content' properties).
    /// </summary>
    [Input(
        Description = "Previous messages in the conversation as a JSON array. Each message should have 'role' (user/assistant) and 'content' properties.",
        UIHint = "multiline")]
    public Input<string?> PreviousMessages { get; set; } = null!;

    /// <summary>
    /// Maximum number of tokens to generate in the response.
    /// </summary>
    [Input(
        Description = "Maximum number of tokens to generate in the response (1-4096).",
        DefaultValue = 1024)]
    public Input<int> MaxTokens { get; set; } = new(1024);

    /// <summary>
    /// Temperature for controlling randomness (0.0 = focused, 1.0 = creative).
    /// </summary>
    [Input(
        Description = "Temperature for controlling response randomness. 0.0 = very focused, 1.0 = very creative.",
        DefaultValue = 0.7)]
    public Input<double?> Temperature { get; set; } = new(0.7);

    /// <summary>
    /// Stop sequences that will end the generation when encountered.
    /// </summary>
    [Input(
        Description = "Stop sequences that will end generation when encountered (comma-separated).")]
    public Input<string?> StopSequences { get; set; } = null!;

    /// <summary>
    /// The generated response from Claude.
    /// </summary>
    [Output(Description = "The text response generated by Claude.")]
    public Output<string> Response { get; set; } = null!;

    /// <summary>
    /// The full response object containing additional metadata.
    /// </summary>
    [Output(Description = "The complete response object with metadata including token usage.")]
    public Output<ClaudeCompletionResponse> FullResponse { get; set; } = null!;

    /// <summary>
    /// The number of input tokens used.
    /// </summary>
    [Output(Description = "The number of input tokens used for this request.")]
    public Output<int> InputTokens { get; set; } = null!;

    /// <summary>
    /// The number of output tokens generated.
    /// </summary>
    [Output(Description = "The number of output tokens generated in the response.")]
    public Output<int> OutputTokens { get; set; } = null!;

    /// <summary>
    /// Executes the activity.
    /// </summary>
    protected override async ValueTask ExecuteAsync(ActivityExecutionContext context)
    {
        var model = context.Get(Model)!;
        var systemPrompt = context.Get(SystemPrompt);
        var userMessage = context.Get(UserMessage)!;
        var previousMessagesJson = context.Get(PreviousMessages);
        var maxTokens = context.Get(MaxTokens);
        var temperature = context.Get(Temperature);
        var stopSequencesInput = context.Get(StopSequences);

        var client = GetClient(context);

        // Build the messages list
        var messages = new List<ClaudeMessage>();

        // Add previous messages if provided
        if (!string.IsNullOrWhiteSpace(previousMessagesJson))
        {
            try
            {
                var previousMessages = System.Text.Json.JsonSerializer.Deserialize<List<ClaudeMessage>>(previousMessagesJson);
                if (previousMessages != null)
                {
                    messages.AddRange(previousMessages);
                }
            }
            catch (System.Text.Json.JsonException)
            {
                // If JSON parsing fails, ignore previous messages and continue
            }
        }

        // Add the current user message
        messages.Add(new ClaudeMessage
        {
            Role = "user",
            Content = userMessage
        });

        // Parse stop sequences
        List<string>? stopSequences = null;
        if (!string.IsNullOrWhiteSpace(stopSequencesInput))
        {
            stopSequences = stopSequencesInput.Split(',', StringSplitOptions.RemoveEmptyEntries)
                                            .Select(s => s.Trim())
                                            .ToList();
        }

        // Create the request
        var request = new ClaudeCompletionRequest
        {
            Model = model,
            MaxTokens = maxTokens,
            Messages = messages,
            System = systemPrompt,
            Temperature = temperature,
            StopSequences = stopSequences
        };

        // Make the API call
        var response = await client.CreateCompletionAsync(request, context.CancellationToken);

        // Extract the response text
        var responseText = response.Content.FirstOrDefault()?.Text ?? string.Empty;

        // Set outputs
        context.Set(Response, responseText);
        context.Set(FullResponse, response);
        context.Set(InputTokens, response.Usage?.InputTokens ?? 0);
        context.Set(OutputTokens, response.Usage?.OutputTokens ?? 0);
    }
}